/**
 * Database connection troubleshooter and fixer
 * 
 * This script diagnoses and fixes common database connection issues by:
 * 1. Testing the database connection
 * 2. Testing different connection string formats
 * 3. Creating a proper .env file with working connection strings
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { PrismaClient } = require('@prisma/client');
const { neon } = require('@neondatabase/serverless');

// Base connection strings
const baseConnectionStrings = {
    pooled: "postgres://neondb_owner:npg_5RtxlHfPjv4d@ep-super-fire-a2zkgpm3-pooler.eu-central-1.aws.neon.tech/neondb",
    direct: "postgres://neondb_owner:npg_5RtxlHfPjv4d@ep-super-fire-a2zkgpm3.eu-central-1.aws.neon.tech/neondb"
};

// Connection parameters to test
const connectionParams = [
    { name: "Basic SSL", params: "?sslmode=require" },
    { name: "Short timeout", params: "?connect_timeout=5&sslmode=require" },
    { name: "Medium timeout", params: "?connect_timeout=15&sslmode=require" },
    { name: "Long timeout", params: "?connect_timeout=30&sslmode=require" },
    { name: "Pooled with short timeout", params: "?connect_timeout=5&sslmode=require&pgbouncer=true&pool_timeout=5" },
    { name: "Pooled with medium timeout", params: "?connect_timeout=15&sslmode=require&pgbouncer=true&pool_timeout=15" },
    { name: "Pooled with long timeout", params: "?connect_timeout=30&sslmode=require&pgbouncer=true&pool_timeout=30" }
];

// Results tracking
const results = [];
let bestConnection = null;

async function testConnection(name, connectionString) {
    console.log(`\nTesting: ${name}`);
    console.log(`Connection string: ${connectionString}`);

    // Test with neon serverless
    try {
        console.log('Testing with neon serverless...');
        const sql = neon(connectionString);
        const startTime = Date.now();
        const result = await sql`SELECT NOW() as now`;
        const duration = Date.now() - startTime;

        console.log(`✅ Connection successful (${duration}ms)`);
        console.log(`Server time: ${result[0].now}`);

        return {
            name,
            connectionString,
            success: true,
            type: 'neon',
            duration,
            error: null
        };
    } catch (error) {
        console.error(`❌ Neon connection failed:`, error.message);

        return {
            name,
            connectionString,
            success: false,
            type: 'neon',
            duration: null,
            error: error.message
        };
    }
}

async function testPrismaConnection(name, connectionString) {
    try {
        console.log('Testing with Prisma...');

        const prisma = new PrismaClient({
            datasources: {
                db: {
                    url: connectionString
                }
            }
        });

        const startTime = Date.now();
        await prisma.$connect();
        const result = await prisma.$queryRaw`SELECT NOW() as now`;
        const duration = Date.now() - startTime;
        await prisma.$disconnect();

        console.log(`✅ Prisma connection successful (${duration}ms)`);
        console.log(`Server time: ${result[0].now}`);

        return {
            name,
            connectionString,
            success: true,
            type: 'prisma',
            duration,
            error: null
        };
    } catch (error) {
        console.error(`❌ Prisma connection failed:`, error.message);

        return {
            name,
            connectionString,
            success: false,
            type: 'prisma',
            duration: null,
            error: error.message
        };
    }
}

function writeEnvFile(bestConnection) {
    if (!bestConnection) {
        console.error('❌ No working connection found. Cannot create .env file.');
        return false;
    }

    // Create direct URL version without pooling
    const directUrl = baseConnectionStrings.direct + "?sslmode=require&connect_timeout=30";

    const envContent = `# Auto-generated by fix-db-connection.js at ${new Date().toISOString()}
# Database Connection
DATABASE_URL=${bestConnection.connectionString}
POSTGRES_PRISMA_URL=${bestConnection.connectionString}
POSTGRES_URL_NON_POOLING=${directUrl}

# NextAuth
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=fd1f312b048a465d8debe3f2d7fe8bbd

# Development mode
NODE_ENV=development
PRISMA_LOG_QUERIES=true
`;

    try {
        // Write to both .env and .env.local
        fs.writeFileSync('.env', envContent);
        fs.writeFileSync('.env.local', envContent);

        console.log('✅ Created .env and .env.local files with working database configuration');
        return true;
    } catch (error) {
        console.error('❌ Error writing .env files:', error);
        return false;
    }
}

async function main() {
    console.log('========= DATABASE CONNECTION TROUBLESHOOTER =========');
    console.log('Testing different connection configurations...');

    // Test each connection variant
    for (const baseType of ['pooled', 'direct']) {
        const baseUrl = baseConnectionStrings[baseType];

        for (const config of connectionParams) {
            const name = `${baseType} - ${config.name}`;
            const connectionString = baseUrl + config.params;

            // Test with neon
            const neonResult = await testConnection(name, connectionString);
            results.push(neonResult);

            // Only test with Prisma if neon connected successfully
            if (neonResult.success) {
                const prismaResult = await testPrismaConnection(name, connectionString);
                results.push(prismaResult);

                // If both succeeded, consider this as a potential best connection
                if (prismaResult.success) {
                    if (!bestConnection || prismaResult.duration < bestConnection.duration) {
                        bestConnection = {
                            name,
                            connectionString,
                            duration: prismaResult.duration
                        };
                    }
                }
            }
        }
    }

    // Summary
    console.log('\n=============== TEST SUMMARY ===============');
    const successfulTests = results.filter(r => r.success);
    console.log(`Total tests: ${results.length}`);
    console.log(`Successful: ${successfulTests.length}`);
    console.log(`Failed: ${results.length - successfulTests.length}`);

    if (bestConnection) {
        console.log('\n✅ Best connection found:');
        console.log(`Name: ${bestConnection.name}`);
        console.log(`Duration: ${bestConnection.duration}ms`);
        console.log(`Connection string: ${bestConnection.connectionString}`);

        // Write to env files
        console.log('\nCreating environment files with optimal configuration...');
        const fileCreated = writeEnvFile(bestConnection);

        if (fileCreated) {
            console.log('\n✅ Database connection fixed!');
            console.log('You can now run your application with:');
            console.log('  npm run dev');
        }
    } else {
        console.log('\n❌ No working connection found.');
        console.log('Please check your network connection and Neon database status.');
    }
}

main().catch(error => {
    console.error('Script error:', error);
}); 